/**
 * 
 */
package fr.ign.cogit.cartagen.agents.core.task;

import java.util.HashSet;
import java.util.Set;

import fr.ign.cogit.cartagen.agents.cartacom.agent.ConversationalObject;
import fr.ign.cogit.cartagen.agents.cartacom.conversation.OnGoingConversation;

/**
 * @author CDuchene
 * 
 */
public abstract class TaskImpl implements Task {

  // //////////////////////////////////////////
  // Fields //
  // //////////////////////////////////////////

  // All static fields //

  // Public fields //

  // Protected fields //

  // Package visible fields //

  // Private fields with public getter //

  /**
   * The conversational object owning the task
   */
  private ConversationalObject taskOwner;
  /**
   * The current status of the task
   */
  private TaskStatus status = TaskStatus.NOT_STARTED;
  /**
   * The current stage of this task. It is strongly recomended that concrete
   * task classes declare static final string variables to refer to there
   * possible stages.
   */
  private String stage = null;
  /**
   * The result of the task. Null until the task is finished.
   */
  private TaskResult result = null;
  /**
   * The tasks that have been aggregated to generate this task and that are now
   * dependent from this task, if any(bidirectional reference, automatically
   * managed).
   */
  private Set<Task> dependentTasks = new HashSet<Task>();

  /**
   * The tasks resulting from the aggregation of this task and others, and from
   * which this task is now dependent, if any.
   */
  private Task aggregatedTask;
  /**
   * The conversations generated by this task, if any (bidirectional reference,
   * automatically managed).
   */
  private Set<OnGoingConversation> generatedConversations = new HashSet<OnGoingConversation>();

  // Very private fields (no public getter) //

  // //////////////////////////////////////
  // All constructors //
  // //////////////////////////////////////

  // //////////////////////////////////////////
  // Static methods //
  // //////////////////////////////////////////

  // //////////////////////////////////////////////////////////
  // All getters and setters //
  // //////////////////////////////////////////////////////////

  /**
   * {@inheritDoc}
   */
  @Override
  public ConversationalObject getTaskOwner() {
    return this.taskOwner;
  }

  /**
   * Setter for the conversational object concerned with this task. Also updates
   * the reverse reference from taskOwner to {@code this}. To break the
   * reference use {@code this.setTaskOwner(null)}
   * @param taskOwner the taskOwner to set
   */
  @Override
  public void setTaskOwner(ConversationalObject taskOwner) {
    ConversationalObject oldTaskOwner = this.taskOwner;
    this.taskOwner = taskOwner;
    if (oldTaskOwner != null) {
      oldTaskOwner.getTasks().remove(this);
    }
    if (taskOwner != null) {
      if (!taskOwner.getTasks().contains(this)) {
        taskOwner.getTasks().add(this);
      }
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Task getAggregatedTask() {
    return this.aggregatedTask;
  }

  /**
   * Setter for the aggregated task this task has generated and is dependent on.
   * Also updates the reverse reference from aggregatedTask to {@code this}. To
   * break the reference use {@code this.setAggregatedTask(null)}.
   * @param aggregatedTask the aggregatedTask to set
   */
  @Override
  public void setAggregatedTask(Task aggregatedTask) {
    Task oldAggregatedTask = this.aggregatedTask;
    this.aggregatedTask = aggregatedTask;
    if (oldAggregatedTask != null) {
      oldAggregatedTask.getDependentTasks().remove(this);
    }
    if (aggregatedTask != null) {
      if (!aggregatedTask.getDependentTasks().contains(this)) {
        aggregatedTask.getDependentTasks().add(this);
      }
    }
  }

  /**
   * {@inheritDoc}
   * <p>
   * 
   */
  @Override
  public Set<Task> getDependentTasks() {
    return this.dependentTasks;
  }

  /**
   * Setter for the set of dependent tasks Also updates the reverse reference
   * from each element of dependentTasks to {@code this}. To break the reference
   * use {@code this.setDependentTasks(new HashSet<Task>())}
   * @param dependentTasks the set of dependent tasks to set
   */
  @Override
  public void setDependentTasks(Set<Task> dependentTasks) {
    Set<Task> oldDependentTasks = new HashSet<Task>(this.dependentTasks);
    for (Task dependentTask : oldDependentTasks) {
      dependentTask.setAggregatedTask(null);
    }
    for (Task dependentTask : dependentTasks) {
      dependentTask.setAggregatedTask(this);
    }
  }

  /**
   * Adds a Task to dependentTasks, and updates the reverse reference from the
   * added Task to {@code this}.
   * @param dependentTask the dependent task to add
   */
  public void addDependentTask(Task dependentTask) {
    if (dependentTask == null) {
      return;
    }
    this.dependentTasks.add(dependentTask);
    dependentTask.setAggregatedTask(this);
  }

  /**
   * Removes a Task from dependentTasks, and updates the reverse reference from
   * the removed Task to {@code null}.
   * @param dependentTask the dependent task to remove
   */
  public void removeDependentTask(Task dependentTask) {
    if (dependentTask == null) {
      return;
    }
    this.dependentTasks.remove(dependentTask);
    dependentTask.setAggregatedTask(null);
  }

  /**
   * {@inheritDoc}
   * <p>
   * 
   */
  @Override
  public Set<OnGoingConversation> getGeneratedConversations() {
    return this.generatedConversations;
  }

  /**
   * Setter for generatedConversations. Also updates the reverse reference from
   * each element of generatedConversations to {@code this}. To break the
   * reference use {@code this.setGeneratedConversations(new
   * HashSet<OnGoingConversation>())}
   * @param generatedConversations the set of generatedConversations to set
   */
  @Override
  public void setGeneratedConversations(
      Set<OnGoingConversation> generatedConversations) {
    Set<OnGoingConversation> oldGeneratedConversations = new HashSet<OnGoingConversation>(
        this.generatedConversations);
    for (OnGoingConversation generatedConversation : oldGeneratedConversations) {
      generatedConversation.setDependentTask(null);
    }
    for (OnGoingConversation generatedConversation : generatedConversations) {
      generatedConversation.setDependentTask(this);
    }
  }

  /**
   * Adds a OnGoingConversation to generatedConversationsSet, and updates the
   * reverse reference from the added OnGoingConversation to <code>this</code>.
   * @param generatedConversation the generated conversation to add
   */
  protected void addGeneratedConversation(
      OnGoingConversation generatedConversation) {
    if (generatedConversation == null) {
      return;
    }
    this.generatedConversations.add(generatedConversation);
    generatedConversation.setDependentTask(this);
  }

  /**
   * Removes a OnGoingConversation from generatedConversationsSet, and updates
   * the reverse reference from the removed OnGoingConversation to {@code null}.
   * @param generatedConversation the generated conversation to remove
   */
  public void removeGeneratedConversation(
      OnGoingConversation generatedConversation) {
    if (generatedConversation == null) {
      return;
    }
    this.generatedConversations.remove(generatedConversation);
    generatedConversation.setDependentTask(null);
  }

  /**
   * {@inheritDoc}
   * <p>
   * 
   */
  @Override
  public TaskResult getResult() {
    return this.result;
  }

  /**
   * Setter for the result of this task.
   * @param result the task result to set (when the task is finished).
   */
  protected void setResult(TaskResult result) {
    this.result = result;
  }

  /**
   * {@inheritDoc}
   * <p>
   * 
   */
  @Override
  public String getStage() {
    return this.stage;
  }

  /**
   * Setter for the stage of this task.
   * @param stage the stage to set
   */
  protected void setStage(String stage) {
    this.stage = stage;
  }

  /**
   * {@inheritDoc}
   * <p>
   * 
   */
  @Override
  public TaskStatus getStatus() {
    return this.status;
  }

  /**
   * Setter for the status of this task
   * @param status the stauts to set
   */
  @Override
  public void setStatus(TaskStatus status) {
    this.status = status;
  }

  // /////////////////////////////////////////////
  // Other public methods //
  // /////////////////////////////////////////////

  /**
   * {@inheritDoc}
   * <p>
   * Clear all references stored in collections: dependent tasks and generated
   * conversations.
   */
  @Override
  public void clean() {
    this.setDependentTasks(new HashSet<Task>());
    this.setAggregatedTask(null);
    this.setGeneratedConversations(new HashSet<OnGoingConversation>());
  }

  // //////////////////////////////////////////
  // Protected methods //
  // //////////////////////////////////////////

  // //////////////////////////////////////////
  // Package visible methods //
  // //////////////////////////////////////////

  // ////////////////////////////////////////
  // Private methods //
  // ////////////////////////////////////////

}
